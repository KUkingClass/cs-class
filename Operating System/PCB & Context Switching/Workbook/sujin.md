# 워크북-PCB & Context Switching

### **Q0. 프로그램과 프로세스의 차이가 뭔가요? ✨**

```
사용자가 프로그램을 클릭하여 실행하면 프로세스가 됩니다.

정적인 상태의 프로그램을 실행해서 메모리에 올리고, 이렇게 메모리에 올라온 것이
동적인 상태의 프로세스 입니다.
```

### **Q1. PCB가 필요한 이유가 뭘까요? ✨**

```
프로그램이 메모리에 올라와 프로세스 상태가 되면, CPU에 프로세스를 로드하여 실제로 
작업을 실행해야 합니다. 

CPU가 프로세스를 실행하기 위해선, 프로세스가 메모리 어디에 올라와 있는지를 알아야하고, 
프로세스간의 context switching이 일어날 때 이전의 프로세스가 어디까지 실행됐는지 정보와,
여러 프로세스를 구별하기 위한 구분자(pid) 등,

프로세스를 실행하는 데 필요한 각종 정보를 저장하기 위해
Process Control Block을 생성하여 관리하는 것입니다.
```

### **Q2. 프로세스의 상태(Ready, Run, Waiting)마다 각각 queue를 두고 PCB를 관리합니다. 왜 전체 프로세스를 하나의 queue로 두고 관리하지 않고 여러 개로 둘까요?**

```
보통 run 상태의 프로세스보다는 ready나 waiting 상태의 프로세스가 훨씬 많고,???
각각의 큐마다 서로 다른 스케줄링 방식을 사용할 수 있는 이점이 있다.

context switching을 위해 PCB를 읽어 상태를 바꾸고 저장해야 하는데,
하나의 큐로 관리한다면 PCB(프로세스)를 찾는데 시간과 비용이 많이 들기 때문에,
각 상태별로 큐를 두어 관리하는 것이 효율적이라고 생각합니다.

또한 run 상태의 프로세스보다는 ready나 waiting 상태의 프로세스가 더 많기도하고,
각각의 큐마다 서로 다른 스케줄링 방식을 사용할 수 있다는 이점이 있습니다.

* 두번째 이유는 뇌피셜인데 맞나요?
```

### **Q3. 프로세스가 실행(running)상태에 있다가 다른 상태로 옮겨갈 수 있습니다. 이 때 실행 상태에서 준비, 대기, 완료 상태로 옮겨가는 경우를 각각 예를 들어 적어보세요.**

```
외부 데이터를 입력 받는 작업을 생각해보면,

실행 -> 준비
대기 상태에 있다가 키보드로 입력을 받는 것을 만족시키면 준비상태가 되고
CPU를 할당 받을 수 있는 후보가 됩니다.

실행 -> 대기
인터럽트가 발생하여 외부 데이터가 필요할 때, 입력이 완료될 때 까지 대기상태입니다.

실행 -> 완료
프로세스 실행이 완료되어 자원을 반납한 상태입니다.
```

### **Q4. PCB에 저장된 것 중, (1) 덕분에 Context Switching 후에 알맞은 명령어를 찾아 실행할 수 있습니다. 또, (2) 덕분에 전에 실행하던 함수를 이어서 실행할 수 있습니다. 이 때, (1)과 (2)는 무엇일까요?**

```
(1) PC (프로그램 카운터) -> 다음에 실행될 명령어의 위치를 가리키는 값, 문맥 교환 후
재 실행 할 프로세스의 위치를 알 수 있다.

(2) 각종 레지스터 정보 -> 함수를 호출할 때 지역변수는 스택 영역에 저장되는데, 이 스택이
어딨는지 가리키는 스택 포인터는 레지스터에 저장되기 때문!
```

### **Q5. Context Switching은 언제 일어날까요? 한 가지 경우만 적어보세요.**

```
예상치 못한 프로세스 작업을 CPU가 처리할 수 있도록 하는
인터럽트 요청이 오면 발생할 수 있습니다.

가장 빈번히 일어나는 입/출력 요청 등이 그 예시입니다.

```

### **Q6. Context Switching은 오버헤드를 발생시킵니다. 이 오버헤드를 줄일 수 있는 방법이 있을까요? ✨**

```
context switching 시
사용된 시간과 사용된 메모리의 양, 즉 오버헤드 비용이 발생하여 성능이 떨어질 수 있는데,

가장 쉽게는 전환이 자주 발생하지 않도록 다중 프로그래밍의 정도를 낮추는 방법이 있고,
경량 프로세스 = 쓰레드를 이용하여 컨텍스트 스위칭 부하를 최소화 하는 방법이 있습니다.

* 다중 프로그래밍 = CPU 작업과 입출력 작업을 병행하는 것
```